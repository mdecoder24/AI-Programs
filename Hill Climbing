import random

def random_solution(tsp):
  """
  Generates a random solution (permutation of cities) for the TSP.

  Args:
      tsp: A 2D list representing the distance matrix between cities.

  Returns:
      list: A list representing a random permutation of city indices.
  """
  cities = list(range(len(tsp)))
  solution = []
  for _ in range(len(tsp)):
    random_city = cities.pop(random.randint(0, len(cities) - 1))
    solution.append(random_city)
  return solution

def route_length(tsp, solution):
  """
  Calculates the total length of the route for a given solution.

  Args:
      tsp: A 2D list representing the distance matrix between cities.
      solution: A list representing a permutation of city indices.

  Returns:
      int: The total distance traveled in the given route.
  """
  length = 0
  for i in range(len(solution) - 1):
    # Add the distance between current city and next city in the solution
    length += tsp[solution[i]][solution[i + 1]]
  # Add the distance from the last city back to the first city to complete the circuit
  length += tsp[solution[-1]][solution[0]]
  return length

def get_neighbors(solution):
  """
  Generates neighboring solutions by swapping two cities.

  Args:
      solution: A list representing a permutation of city indices.

  Returns:
      list: A list of neighboring solutions where each neighbor is created by swapping two cities in the original solution.
  """
  neighbors = []
  for i in range(len(solution)):
    for j in range(i + 1, len(solution)):
      # Create a neighbor by swapping the positions of two cities
      neighbor = solution.copy()
      neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
      neighbors.append(neighbor)
  return neighbors

def get_best_neighbor(tsp, neighbors):
  """
  Finds the best neighboring solution (shortest route) among a list of neighbors.

  Args:
      tsp: A 2D list representing the distance matrix between cities.
      neighbors: A list of lists, where each inner list represents a neighboring solution (permutation of city indices).

  Returns:
      tuple: A tuple containing the best neighboring solution and its corresponding route length.
  """
  best_length = route_length(tsp, neighbors[0])
  best_neighbor = neighbors[0]
  for neighbor in neighbors:
    # Calculate the length of the current neighbor's route
    current_length = route_length(tsp, neighbor)
    # Update best length and best neighbor if current neighbor's length is shorter
    if current_length < best_length:
      best_length = current_length
      best_neighbor = neighbor
  return best_neighbor, best_length

def hill_climbing(tsp):
  """
  Hill Climbing algorithm to find the shortest route for the TSP.

  Args:
      tsp: A 2D list representing the distance matrix between cities.

  Returns:
      tuple: A tuple containing the best solution found (permutation of city indices) and its corresponding route length.
  """
  # Generate a random initial solution
  current_solution = random_solution(tsp)
  current_length = route_length(tsp, current_solution)

  # Get neighboring solutions
  neighbors = get_neighbors(current_solution)

  # Find the best neighboring solution (shortest route)
  best_neighbor, best_length = get_best_neighbor(tsp, neighbors)

  # Continue until no better neighbor can be found (local optimum)
  while best_length < current_length:
    # Move to the best neighbor (shorter route)
    current_solution = best_neighbor
    current_length = best_length

    # Get neighbors of the current solution
    neighbors = get_neighbors(current_solution)

    # Find the best neighbor among them
    best_neighbor, best_length = get_best_neighbor(tsp, neighbors)

  # Return the best solution found and its length
  return current_solution, current_length

# Example TSP matrix
tsp = [[0, 400, 500, 300],
       [400, 0, 300, 500],
       [500, 300, 0, 400],
       [300, 500, 400, 0]]

print(hill_climbing(tsp))

